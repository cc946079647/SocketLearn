Unix支持５中可用的I/O模型
１、阻塞式I/O
２、非阻塞式I/O
３、I/O复用
４、信号驱动I/O
５、异步I/O

一个输入操作，通常包括两个不同的阶段：
１、等待数据在内核中准备好
２、从内核中向进程空间复制数据

１、阻塞式I/O
默认情况下，所有的套接字都是阻塞的。即用户空间内调用函数，通过系统调用陷入内核。内核中等待数据准备好，当数据准备完成后复制数据到用户空间。完成后从用户调用的函数返回。
２、非阻塞式I/O
进程将一个套接字设为非阻塞就是通知内核，当发现操作无法继续完成需要将用户空间代码阻塞时，不要将用户代码阻塞，而是立刻返回，通过返回值告知用户代码。用户代码中可以反复调用直到获得数据。
３、I/O复用
用户代码中可以设置多个需要处理的套接字并在select中注册并告知内核对这些套接字感兴趣的事件，如可读、可写、accept等。之后用户代码调用select并阻塞。当内核发现注册的套接字中有任何满足条件的时便返回，用户代码可以找到满足条件的套接字并进行处理。
４、信号驱动I/O模型
通过注册SIGIO信号处理程序进行。用户代码首先注册对SIGIO事件的处理程序，之后完成其他工作。SIGIO信号发生时回调用户代码中注册的函数。
５、异步I/O
用户代码通过异步I/O系统调用提供套接字、缓冲区、缓冲区大小、回调方法给内核。当数据准备好后内核会主动将数据复制到用户空间，当复制完成后调用回调函数。异步I/O与信号驱动的区别在于信号是当数据准备好时通知用户代码，由用户代码进行数据copy，而异步I/O则是内核copy完成数据后才通知用户代码。

POSIX定义了两个术语：
１、同步I/O操作：导致请求进程阻塞，直到I/O操作完成的操作。
２、异步I/O操作：不导致请求进程阻塞的操作。

Select的不足：
1、底层内核轮询关注的fd，当fd较多时花费大量资源；
2、作为参数的fd_set被内核修改，每次调用select时都会从用户空间copyfd_set参数。当fd_set较大时消耗资源。
3、从select返回后要循环寻找相应的fd，当fd较多时花费时间，影响对后续事件的处理。
Poll：
poll与select的区别仅在于描述事件和fd的方式。其余部分相同。

epoll;
在内核中为关心的fd设置回调函数，当关心的fd事件发生时调用回调函数，讲fd放入一个就绪链表中。进程醒来时发现就绪链表不为空就返回，为空继续sleep。而select/poll 进程在醒时需要轮询fd。
epol采用红黑树管理fd数据，只需要在调用epoll_create的时候开辟红黑树空间，并在用户调用epoll_stl的时候根据cmd对红黑树做维护就可以了。
